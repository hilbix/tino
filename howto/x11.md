# X11 howto

## `su` => `xsu`

Problem:

You are logged on with X11 to one account and you need to run some X11 app on another account.

> Same machine, other account.

I tried, but none of the solutions out there worked for me.  Here is a short working recipe which automatically detects, which line of `xauth` is for your display:

> Do not leave away any quote!
>
> **Security Warning!**
>
> This recipe leaves `xauth` in `$OTHERACCOUNT` active.  Hence **the other account can abuse your X11 session afterwards**!
>
> There is no way to protect the MIT_MAGIC_COOKIE from being stolen by some evil `$OTHERACCOUNT` once it has been added via `xauth`.
>
> **Cleanup of the MIT_MAGIC_COOKIE afterwards is pseudo security, not giving you any protection, except that you are fooled to be secure, but you aren't!**
>
> If something is worse than no security at all it is pseudo security, which does not keep you stay alert.

```
AUTH="`xauth list`" su --whitelist-environment=AUTH,DISPLAY - "$OTHERACCOUNT"
exec bash -l
while read -r line; do xauth add $line && xhost >/dev/null || continue; unset AUTH; break; done <<< "$AUTH"
```

> `xauth` and `xhost` should always be available.  But if `xhost` is not what you want to use for tests,
> try some other command which immediately and always returns success if `$DISPLAY` works:
>
> `xdpyinfo`, `xmodmap`, `xdotool getmouselocation`
>
> Not suitable are commands like `xclip`, which may fail too many ways.

How to automate this recipe?

```
xsu()
{
  AUTH="`xauth list`" su --whitelist-environment=AUTH,DISPLAY --shell="/bin/sh" --pty -- - "$1" -c '
    oIFS="$IFS"
    IFS="
"
    for line in $AUTH;
    do
      IFS="$oIFS";
      xauth add $line && xhost >/dev/null || continue;
      unset AUTH;
      break;
    done;
    IFS="$oIFS";
    [ 0 = $# ] && exec "$SHELL" -l;
    exec "$SHELL" -c "exec \"\$@\"" "$SHELL" "$@";
  ' "$@"
}
```

Then just run `xsu user` or `xsu user cmd args..`.

> This should work for all Bourne Shells.  I nearly always use `/bin/bash` with fallback to `ksh` in case `bash` is not available.

As simple as it can get.

> Fore easy debugging, if all lines in `AUTH` fail, it is left in the environment.
>
> Some other non-obvious details:
>
> - `bash -c 'echo "$@"' a b c` outputs `b c`, as `$0` is not part of `$@`.
>   - This fact is (ab)used above in the 2nd last line `' "$@"`.
> - There is no easy way to split things into lines, as the bashism `<<<` is not available in basic Bourne Shells.
>   - Hence the `IFS` trick
> - `for line in $AUTH` is not entirely safe.  As something like `$AUTH` could contain shell quantors (`?` or `*`) which are expanded.
>   - In this case here it stems from `xauth list`, so there should not be such things.
>   - And even if `xauth` is trojaned, no really bad things can happen, except for some weird DoS which causes no other real harm.
